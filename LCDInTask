#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    batVolt,        sensorAnalog)
#pragma config(Sensor, dgtl1,  Launcher,       sensorDigitalOut)
#pragma config(Sensor, dgtl6,  ramps,          sensorDigitalOut)
#pragma config(Sensor, dgtl10, bigLaunch,      sensorDigitalOut)
#pragma config(Sensor, dgtl11, bigBallLift,    sensorDigitalOut)
#pragma config(Sensor, dgtl12, Arm,            sensorDigitalOut)
#pragma config(Sensor, I2C_1,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rigthEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rightFlash,    tmotorVex269_HBridge, openLoop)
#pragma config(Motor,  port2,           rightIntake,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           wheel1,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           wheel24,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           wheel3,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port6,           wheel6,        tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port7,           wheel57,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           wheel8,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftIntake,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          leftFlash,     tmotorVex269_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DeBuggerWindows("Globals")
#pragma DeBuggerWindows("Locals")
#pragma DeBuggerWindows("VexLCD")
#pragma DeBuggerWindows("Sensors")
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)



#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

task LCD;
int count = 0;
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(10);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
//
//Code segment: waitForPress(); Procedure: 7
//
	while(nLCDButtons != 0){}

	wait1Msec(10);
}
void displayBatteryVoltage() {
	string mainBattery, batteryVoltage;
	displayLCDString(0, 0, "Primary: ");
	displayLCDString(1, 0, "PowerExp: ");
	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
	sprintf(batteryVoltage, "%1.2f%c", (SensorValue[batVolt] /280), 'V');//OPEN THE BOMB BAY DOORS HAL!! I'm afraid I can't do that ...
	setLCDPosition(0,10);
	displayNextLCDString(mainBattery);
	setLCDPosition(1, 10);
	displayNextLCDString(batteryVoltage);
	wait1Msec(100);
}





/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////


//typedef struct
//{
//	float Ki;
//	float Kp;
//	float Kd;
//	float error;
//	float integral;
//	float derivative;
//	float targetVal;
//	float lastError;
//	bool isRunning;
//	}
//PIDController;

//Wait for Press--------------------------------------------------
task LCD()
{
		bLCDBacklight = true;
	clearLCDLine(0);
	clearLCDLine(1);

		while(nLCDButtons != centerButton)
	{

		//Switch case that allows the user to choose from 4 different options
		switch(count){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "Red Middle Mode");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{

				waitForRelease();
				count = 3;
			}
			else if(nLCDButtons == rightButton)
			{

				waitForRelease();
				count++;
			}

			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "Blue Middle Mode");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{

				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{

				waitForRelease();
				count++;
			}

			break;
		case 2:
			//Display third choice
			displayLCDCenteredString(0, "Red Middle Bash");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{

				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{

				waitForRelease();
				count++;
			}

			break;
		case 3:
			//Display fourth choice
			displayLCDCenteredString(0, "Blue Middle Bash");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{

				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{

				waitForRelease();
				count = 0;
			}

			break;
		default:
			count = 0;
			break;

		}
	}

}

void pre_auton()
{
 	SensorValue[Launcher] = 1;
  SensorValue[bigLaunch] = 1;
  motor[leftFlash] = 127;
	motor[rightFlash] = 127;

 	bLCDBacklight = true;
	clearLCDLine(0);
	clearLCDLine(1);
	startTask(LCD, 8);


}

void forwardReverse(int x)
{
	motor[wheel1] = x;
	motor[wheel24] = x;
	motor[wheel3] = x;
	motor[wheel57] = x;
	motor[wheel6] = x;
	motor[wheel8] = x;
}

void turnLeft()
{
	motor[wheel1] = 127;
	motor[wheel24] = 127;
	motor[wheel3] = 127;
	motor[wheel57] = -127;
	motor[wheel6] = -127;
	motor[wheel8] = -127;
}
void turnRight()
{
	motor[wheel1] = -127;
	motor[wheel24] = -127;
	motor[wheel3] = -127;
	motor[wheel57] = 127;
	motor[wheel6] = 127;
	motor[wheel8] = 127;
}
void intake()
{
	motor[leftIntake] = -127;
	motor[rightIntake] = -127;
}
void outake()
{
	motor[leftIntake] = 127;
	motor[rightIntake] = 127;
}
void liftUp()
{
	SensorValue[Arm] = 1;
	SensorValue[bigBallLift] = 1;
	wait1Msec(2000);
}
void liftBig()
{
	SensorValue[Arm] = 1;

}
void liftDown()
{
	SensorValue[Arm] = 0;
	SensorValue[bigBallLift] = 0;
	wait1Msec(3000);
}
void strafeLeft()
{
	motor[wheel1] = 127;
	motor[wheel24] = -127;
	motor[wheel3] = 127;
	motor[wheel57] = 127;
	motor[wheel6] = -127;
	motor[wheel8] = -127;
}
void strafeRight()
{
	motor[wheel1] = -127;
	motor[wheel24] = 127;
	motor[wheel3] = -127;
	motor[wheel57] = -127;
	motor[wheel6] = 127;
	motor[wheel8] = 127;
}
void halt()
{
	motor[wheel1] = 0;
	motor[wheel24] = 0;
	motor[wheel3] = 0;
	motor[wheel57] = 0;
	motor[wheel6] = 0;
	motor[wheel8] = 0;
}
void clearEncoders()
{
	nMotorEncoder[wheel3] = 0;
	nMotorEncoder[wheel6] = 0;
}

void StopIntake()
{
	motor[leftIntake] = 0;
	motor[rightIntake] = 0;
}



/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count)
	{
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "Red Middle Mode");//red middle zone autonomous
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2);
		outake();				 //outakes for 1 sec. then intakes for one sec.
		wait1Msec(1000);
		intake();
		wait1Msec(1000);
		SensorValue[Launcher] = 0;
		liftUp();
		liftBig();

		clearEncoders();
		while((nMotorEncoder[wheel3] < 880)&& (nMotorEncoder[wheel6] > -880))
		{
			forwardReverse(127);
		}
		halt();
		wait1Msec(200);
		clearEncoders();
		while((nMotorEncoder[wheel3] > -670)&& (nMotorEncoder[wheel6] < 670))
		{
			forwardReverse(-127);
		}
		halt();
		wait1Msec(500);
		clearEncoders();
		while(nMotorEncoder[wheel3] > -1350)
		{
			strafeRight();
		}
		halt();
		wait1Msec(500);
		clearEncoders();
		while((nMotorEncoder[wheel3] < 700)&& (nMotorEncoder[wheel6] > -700))
		{
			forwardReverse(127);
		}
		halt();
			wait1Msec(500);
		clearEncoders();
		while((nMotorEncoder[wheel3] > -200)&& (nMotorEncoder[wheel6] < 200))
		{
			forwardReverse(-127);

		}
		liftDown();
		halt();
		wait1Msec(200);
		clearEncoders();
		while(nMotorEncoder[wheel3] < 1000)
		{
			strafeLeft();
		}
		halt();
		wait1Msec(200);
		clearEncoders();
		while((nMotorEncoder[wheel3]< 1225)&& (nMotorEncoder[wheel6] > -1225))
		{
			forwardReverse(127);
		}
		halt();
		wait1Msec(200);
		clearEncoders();
		while(nMotorEncoder[wheel3] > -480)
		{
			strafeRight();
		}
		halt();
		liftUp();
		clearEncoders();
		while((nMotorEncoder[wheel3] < 470)&& (nMotorEncoder[wheel6] > -470))
		{
			forwardReverse(127);
		}
		halt();


		outake();
		wait1Msec(2000);//outakes preload into goal
		StopIntake();
		break;
		case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "Blue Middle Mode");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2);
		outake();
		wait1Msec(1000);
		intake();
		wait1Msec(1000);
	//outakes then intakes and then raises arm
		SensorValue[Launcher] = 0;
		liftUp();

		clearEncoders();
		while((nMotorEncoder[wheel3] < 880)&& (nMotorEncoder[wheel6] > -880))
		{
			forwardReverse(127);
		}
		halt();
		wait1Msec(500);
		clearEncoders();
		while((nMotorEncoder[wheel3] > -670)&& (nMotorEncoder[wheel6] < 670))
		{
			forwardReverse(-127);
		}
		halt();
		clearEncoders();
		while(nMotorEncoder[wheel3] < 1350)
		{
			strafeLeft();
		}
		halt();
		wait1Msec(200);
		clearEncoders();
		while((nMotorEncoder[wheel3] < 700)&& (nMotorEncoder[wheel6] > -700))
		{
			forwardReverse(127);
		}
		halt();
			wait1Msec(200);
		clearEncoders();
		while((nMotorEncoder[wheel3]>-500)&& (nMotorEncoder[wheel6] < 500))
		{
			forwardReverse(-127);

		}
		halt();
		liftDown();

		clearEncoders();
		while(nMotorEncoder[wheel3] > -800)
		{
			strafeRight();
		}
		halt();
		wait1Msec(200);
		clearEncoders();
		while((nMotorEncoder[wheel3] < 1225)&& (nMotorEncoder[wheel6] > -1225))
		{
			forwardReverse(127);
		}
		halt();
		StopIntake();
		wait1Msec(200);
		clearEncoders();
		while(nMotorEncoder[wheel3] < 480)
		{
			strafeLeft();
		}
		halt();
		liftUp();
		clearEncoders();
		while((nMotorEncoder[wheel3]< 370) && (nMotorEncoder[wheel6] > -370))
		{
			forwardReverse(127);
		}
		halt();

		outake();
		wait1Msec(2000);//outakes for 2 sec.
		StopIntake();
		break;
		case 2:
		//If count = 2, run the code correspoinding with choice 3
		displayLCDCenteredString(0, "Red Middle Bash");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2);
		outake();				 //outakes for 1 sec. then intakes for one sec.
		wait1Msec(1000);
		intake();
		wait1Msec(1000);
		SensorValue[Launcher] = 0;
		liftUp();
		clearEncoders();
		while((nMotorEncoder[wheel3] < 880)&& (nMotorEncoder[wheel6] > -880))
		{
			forwardReverse(127);
		}
		halt();
		wait1Msec(200);
		clearEncoders();
		while((nMotorEncoder[wheel3] > -670)&& (nMotorEncoder[wheel6] < 670))
		{
			forwardReverse(-127);
		}
		halt();
		wait1Msec(200);
		clearEncoders();
		while(nMotorEncoder[wheel3] > -1350)
		{
			strafeRight();
		}
		halt();
		wait1Msec(200);
		clearEncoders();
		while((nMotorEncoder[wheel3] < 700)&& (nMotorEncoder[wheel6] > -700))
		{
			forwardReverse(127);
		}
		halt();
		wait1Msec(200);
		clearEncoders();
		while((nMotorEncoder[wheel3] > -500)&& (nMotorEncoder[wheel6] < 500))
		{
			forwardReverse(-127);

		}
		liftDown();
		halt();
		wait1Msec(200);
		clearEncoders();
		while(nMotorEncoder[wheel3] < 800)
		{
			strafeLeft();
		}
		halt();
		wait1Msec(200);
		clearEncoders();
		while((nMotorEncoder[wheel3]< 1225)&& (nMotorEncoder[wheel6] > -1225))
		{
			forwardReverse(127);
		}
		halt();
		wait1Msec(200);
		clearEncoders();
		while(nMotorEncoder[wheel3] > -480)
		{
			strafeRight();
		}
		halt();
		liftUp();
		clearEncoders();
		while((nMotorEncoder[wheel3] < 470)&& (nMotorEncoder[wheel6] > -470))
		{
			forwardReverse(127);
		}
		halt();
		outake();
		wait1Msec(2000);//outakes preload into goal
		StopIntake();
		clearEncoders();
		while((nMotorEncoder[wheel3]> -200) && (nMotorEncoder[wheel6] < 200))
		{
			forwardReverse(-127);
		}
		halt();
		liftDown();
		clearEncoders();
		while(nMotorEncoder[wheel3] < 900)
		{
			turnLeft();
		}
		halt();
		clearEncoders();
		while(nMotorEncoder[wheel3] > -2000)
		{
			forwardReverse(-127);
		}
		halt();
		break;
		case 3:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "Blue Middle Bash");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2);
			outake();
		wait1Msec(1000);
		intake();
		wait1Msec(1000);
	//outakes then intakes and then raises arm
		SensorValue[Launcher] = 0;
		liftUp();
		clearEncoders();
		while((nMotorEncoder[wheel3] < 880)&& (nMotorEncoder[wheel6] > -880))
		{
			forwardReverse(127);
		}
		halt();
		wait1Msec(200);
		clearEncoders();
		while(nMotorEncoder[wheel3] < 1350)
		{
			strafeLeft();
		}
		halt();
		wait1Msec(200);
		clearEncoders();
		while((nMotorEncoder[wheel3] < 700)&& (nMotorEncoder[wheel6] > -700))
		{
			forwardReverse(127);
		}
		halt();
		wait1Msec(200);
		clearEncoders();
		while((nMotorEncoder[wheel3]>-500)&& (nMotorEncoder[wheel6] < 500))
		{
			forwardReverse(-127);

		}
		halt();
		liftDown();
		clearEncoders();
		while(nMotorEncoder[wheel3] > -800)
		{
			strafeRight();
		}
		halt();
		wait1Msec(200);
		clearEncoders();
		while((nMotorEncoder[wheel3] < 1225)&& (nMotorEncoder[wheel6] > -1225))
		{
			forwardReverse(127);
		}
		halt();
		StopIntake();
		wait1Msec(200);
		clearEncoders();
		while(nMotorEncoder[wheel3] < 480)
		{
			strafeLeft();
		}
		halt();
		liftUp();
		clearEncoders();
		while((nMotorEncoder[wheel3]< 370) && (nMotorEncoder[wheel6] > -370))
		{
			forwardReverse(127);
		}
		halt();
		outake();
		wait1Msec(2000);//outakes for 2 sec.
		StopIntake();
		clearEncoders();
		while((nMotorEncoder[wheel3]> -400)&& (nMotorEncoder[wheel6]< 400))
		{
			forwardReverse(-127);

		}
		halt();
		liftDown();
		clearEncoders();
		while(nMotorEncoder[wheel6] > -900)
		{
			turnRight();
		}
		halt();
		clearEncoders();
		while((nMotorEncoder[wheel3]> -2000)&& (nMotorEncoder[wheel6] < 2000))
		{
			forwardReverse(-127);

		}
		halt();
		break;


		default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;



}











}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{
	bLCDBacklight = true;
	clearLCDLine(0);
	clearLCDLine(1);


	int driverspeed;

		displayBatteryVoltage();


		if(vexRT[Btn5U]==1)
		{
			driverspeed = 1;
		}

		else
		{
			driverspeed = 2;
		}
		if(vexRT[Btn5D] == 1)
		{
			SensorValue[bigLaunch] = 1;
			SensorValue[Launcher] = 1;
		}
		if(vexRT[Btn6U] ==1)
		{
			SensorValue[Launcher] = 1;
		}
		else if (vexRT[Btn6D] ==1)
		{
			SensorValue[Launcher] = 0;
			SensorValue[bigLaunch] = 0;

		}
		if(vexRT[Btn8U] == 1)
		{
			SensorValue[ramps] = 1;
		}
		else if(vexRT[Btn8D] == 1)
		{
			SensorValue[ramps] = 0;
		}

		if(vexRT[Btn6UXmtr2] == 1)
		{
				SensorValue[Arm] = 1;

		}

		if(vexRT[Btn7UXmtr2] ==1)
		{
			SensorValue[Arm] = 1;
			SensorValue[bigBallLift] = 1;
		}
		else if(vexRT[Btn7DXmtr2] == 1)
		{
			SensorValue[Arm] = 0;
			SensorValue[bigBallLift] = 0;
		}

		motor[leftIntake]= vexRT[Ch2Xmtr2];
		motor[rightIntake] = vexRT[Ch2Xmtr2];
		switch(driverspeed)
		{
		case 1:

		motor[wheel1] = (vexRT[Ch3] - vexRT[Ch4] - vexRT[Ch1])/2;
		motor[wheel24] = (vexRT[Ch3] - vexRT[Ch4] + vexRT[Ch1])/2;
		motor[wheel3] = (vexRT[Ch3] - vexRT[Ch4] - vexRT[Ch1])/2;
		motor[wheel6] = (vexRT[Ch3] + vexRT[Ch4] + vexRT[Ch1])/2;
		motor[wheel57] = (vexRT[Ch3] + vexRT[Ch4] - vexRT[Ch1])/2;
		motor[wheel8] = (vexRT[Ch3] + vexRT[Ch4] + vexRT[Ch1])/2;
		break;

		case 2:

		motor[wheel1] = vexRT[Ch3] - vexRT[Ch4] - vexRT[Ch1];
		motor[wheel24] = vexRT[Ch3] - vexRT[Ch4] + vexRT[Ch1];
		motor[wheel3] = vexRT[Ch3] - vexRT[Ch4] - vexRT[Ch1];
		motor[wheel6] = vexRT[Ch3] + vexRT[Ch4] + vexRT[Ch1];
		motor[wheel57] = vexRT[Ch3] + vexRT[Ch4] - vexRT[Ch1];
		motor[wheel8] = vexRT[Ch3] + vexRT[Ch4] + vexRT[Ch1];
		break;
	}


	}
}
