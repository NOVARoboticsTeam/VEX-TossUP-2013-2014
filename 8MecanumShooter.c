 #pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl11, solenoid1,      sensorDigitalOut)
#pragma config(Sensor, dgtl12, solenoid2,      sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftRear,      tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port2,           leftFront,     tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port3,           topShooter,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           bottomShooter, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           leftArm,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightArm,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           intake,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           flap,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightFront,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port10,          rightRear,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
bool SHOOTERENABLE = false;

/*#define MOTOR_NUM               2
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 10      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        15      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10

// Array to hold requested speed for the motors
int motorReq[ MOTOR_NUM ];

// Array to hold "slew rate" for the motors, the maximum change every time the task
// runs checking current mootor speed.
int motorSlew[ MOTOR_NUM ];*/

void shooter()
{
	motor[topShooter] = 127;
	motor[bottomShooter] = 127;
}

void stopShooter(){
	motor[topShooter] = 0;
	motor[bottomShooter] = 0;
}
void forward(int speed)
{
	motor[rightFront] = speed;
	motor[rightRear] = speed;
	motor[leftFront] = speed;
	motor[leftRear] = speed;
}
void reverse(int speed)
{
	motor[rightFront] = -speed;
	motor[rightRear] = -speed;
	motor[leftFront] = -speed;
	motor[leftRear] = -speed;


}
void turnRight(int speed)

{
	motor[rightFront] = -speed;
	motor[rightRear] = -speed;
	motor[leftFront] = speed;
	motor[leftRear] = speed;
}
void turnLeft(int speed)
{
	motor[rightFront] = speed;
	motor[rightRear] = speed;
	motor[leftFront] = -speed;
	motor[leftRear] = -speed;
}
void halt()
{
	motor[rightFront] = 0;
	motor[rightRear] = 0;
	motor[leftFront] = 0;
	motor[leftRear] = 0;
}
void resetEncoders()
{
	nMotorEncoder[leftFront]=0;
	nMotorEncoder[leftRear]=0;
	nMotorEncoder[rightFront]=0;
	nMotorEncoder[rightRear]=0;
}
// Strafing Functions - Enables the robot to move laterally at an indicated speed by the user.
void strafeRight(int speed)
{
	motor[rightFront] = -speed;
	motor[rightRear] = speed;
	motor[leftFront] = speed;
	motor[leftRear] = -speed;
}
void strafeLeft(int speed)
{
	motor[rightFront] = speed;
	motor[rightRear] = -speed;
	motor[leftFront] = -speed;
	motor[leftRear] = speed;
}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  SensorValue[solenoid1] = 1;
  SensorValue[solenoid2] = 1;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{

	resetEncoders();
	shooter();
	motor[intake] = 127;
	wait1Msec(1500);
  /*while(nMotorEncoder[leftRear] < 425) // Robot moves forward to pick up game first game object directly in front of it
  {
  	forward(63);
  }*/
  halt();
  stopShooter();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{
	 			motor[leftFront] = vexRT[Ch3] - vexRT[Ch4];
				motor[rightFront] = vexRT[Ch2] + vexRT[Ch1];
				motor[leftRear] = vexRT[Ch3] + vexRT[Ch4];
				motor[rightRear] = vexRT[Ch2] - vexRT[Ch1];
				if(vexRT[Btn5U] == 1)
				{
					motor[leftArm] = 95;
					motor[rightArm] = 95;
				}
				else if(vexRT[Btn5D] == 1)
				{
					motor[leftArm] = -95;
					motor[rightArm] = -95;
				}
				else {
					motor[leftArm] = 0;
					motor[rightArm] = 0;
				}
				if(vexRT[Btn6U] == 1)
				{
					SensorValue[solenoid1] = 1;
					SensorValue[solenoid2] = 1;
				}
				else if(vexRT[Btn6D] == 1)
				{
					SensorValue[solenoid1] = 0;
					SensorValue[solenoid2] = 0;
				}
				if(vexRT[Btn7U] == 1)
				{
					motor[intake] = -127;
				}
				else if(vexRT[Btn7D] == 1){
					motor[intake] = 127;
				}
				else {
					motor[intake] = 0;
				}
				if(vexRT[Btn8U] == 1)
				{
					motor[flap] = 95;
				}
				else if(vexRT[Btn8D] == 1)
				{
					motor[flap] = -95;
				}
				else
				{
					motor[flap] = 0;
				}
				if(vexRT[Btn7R] == 1)
				{
					motor[topShooter] = 127;
					motor[bottomShooter] = 127;
				}
				else if(vexRT[Btn7L] == 1)
				{
					motor[topShooter] = -127;
					motor[bottomShooter] = -127;
				}
				else {
					motor[topShooter] = 0;
					motor[bottomShooter] = 0;
				}

	}
}
