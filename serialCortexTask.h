


//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*                        Copyright (c) James Pearman                          */
/*                                   2013                                      */
/*                            All Rights Reserved                              */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*        Module:     serialCortex.c                                           */
/*        Author:     James Pearman                                            */
/*        Created:    5 August 2013                                            */
/*                                                                             */
/*        Revisions:  V0.1                                                     */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    Description:                                                             */
/*                                                                             */
/*    Demonstration code for serial comms transmition from Arduino to          */
/*    VEX cortex.                                                              */
/*                                                                             */
/*    Licensed under the Apache License, Version 2.0 (the "License");          */
/*    you may not use this file except in compliance with the License.         */
/*    You may obtain a copy of the License at                                  */
/*                                                                             */
/*    http://www.apache.org/licenses/LICENSE-2.0                               */
/*                                                                             */
/*    Unless required by applicable law or agreed to in writing, software      */
/*    distributed under the License is distributed on an "AS IS" BASIS,        */
/*    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. */
/*    See the License for the specific language governing permissions and      */
/*    limitations under the License.                                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
#define DEBUG 0


// Storage for the vex communications data
typedef struct _vdata {
      unsigned char  header_aa;
      unsigned char  header_55;
      unsigned char  message_type;
      unsigned char  datalen;
      unsigned short irDirection;
      unsigned short irDirectionAngle;
      unsigned short irStrength;
      unsigned short var_4;
      unsigned short var_5;
      unsigned short var_6;
      unsigned short var_7;
      unsigned short var_8;
      unsigned char  id;
      unsigned char  checksum;
      } vdata;

#define  VEXDATAOFFSET         4
#define  VEX_DATA_BUFFER_SIZE  sizeof(vdata)

typedef union _vexdata {
      vdata          data;
      unsigned char  buffer[VEX_DATA_BUFFER_SIZE];
      } vexdata;

vexdata  MyVexDataRx;

// globals storage for the demo variables
unsigned short  vars[8];

int     serialErrs = 0;

/*-----------------------------------------------------------------------------*/
/*  Initialize the VEX data                                                    */
/*-----------------------------------------------------------------------------*/

void
VexDataInit( vexdata *v )
{
    int  i;

    // clear all
    for(i=0;i<VEX_DATA_BUFFER_SIZE;i++)
      v->buffer[i] = 0;

    // Initialize packet
    v->data.header_aa    = 0xAA; // header for VEX message - byte 1
    v->data.header_55    = 0x55; // header for VEX message - byte 2
    v->data.message_type = 0x00; // message type found from data packet
    v->data.datalen      = 0x00; // data len found from rx data packet
    v->data.id           = 0x00; // increments by 1 for each message
}

/*-----------------------------------------------------------------------------*/
/*  Calculate the checksum for the packet                                      */
/*-----------------------------------------------------------------------------*/

void
VexDataChecksum( vexdata  *v )
{
    int  i;
    int  cs = 0;

    // calculate checksum
    for(i=0;i<(VEX_DATA_BUFFER_SIZE-1);i++)
      cs += v->buffer[i];

    v->data.checksum = 0x100 - (cs & 0xFF);
}

/*-----------------------------------------------------------------------------*/
/*  Debugging print for the VEX data                                           */
/*-----------------------------------------------------------------------------*/

void
VexDataPrint( vexdata  *v )
{
    int  i;
    char  str[4];
    for(i=0;i<(VEXDATAOFFSET+v->data.datalen+2);i++)
      {
      sprintf(str, "%02X ", v->buffer[i]);
      writeDebugStream(str);
      writeDebugStream("Direction:  %d ", vars[0]);

      }


    writeDebugStreamLine("");
}

/*-----------------------------------------------------------------------------*/
/*  Process the received data                                                  */
/*-----------------------------------------------------------------------------*/

void
serialRxDecode( vexdata  *v  )
{
   // Move the data to output variables
    vars[0] = v->data.irDirection;
    vars[1] = v->data.irDirectionAngle;
    vars[2] = v->data.irStrength;
    vars[3] = v->data.var_4;
    vars[4] = v->data.var_5;
    vars[5] = v->data.var_6;
    vars[6] = v->data.var_7;
    vars[7] = v->data.var_8;
}

/*-----------------------------------------------------------------------------*/
/*  Timeout code                                                               */
/*-----------------------------------------------------------------------------*/

void
serialTimeoutStart( long *t )
{
    // Start timeout
    *t = nSysTime;
}

void
serialTimeoutStop( long *t )
{
    // Stop timeout
    *t = 0;
}

int
serialTimeoutCheck( long *t )
{
    // Is timeout running
    if( *t > 0 )
        {
        if(nSysTime - *t < 10)
            return(0);
        else
            {
            serialTimeoutStop( t );
            return(1);
            }
        }

    return(0);
}

/*-----------------------------------------------------------------------------*/
/*  Receive one character, returns (-1) if nothing available                   */
/*-----------------------------------------------------------------------------*/

int
serialRxChar()
{
    return(getChar(UART1));
}

/*-----------------------------------------------------------------------------*/
/*  Message receive state machine                                              */
/*-----------------------------------------------------------------------------*/

typedef enum {
    kRxStateIdle = 0,
    kRxStateHeader,
    kRxStateId,
    kRxStateMessageType,
    kRxStateDatalen,
    kRxStateData,
    kRxStateChecksum
    } rxState;

void
serialRx( vexdata  *v )
{
    static  rxState  serialRxState  = kRxStateIdle;
    static  int      serialDataReceived = 0;
    static  long     timeout            = 0;

    int    c;

    // Check for inter char timeout
    if( serialTimeoutCheck(&timeout) == 1 )
        {
        serialErrs++;
        serialRxState = kRxStateIdle;
        }

    // check for a received character
    while( (c == serialRxChar()) >= 0 )
        {
        // A new character has been received so process it.

        // Start inter char timeout
        serialTimeoutStart( &timeout );

        // Where are we in the message parsing process ?
        switch( serialRxState )
            {
            case  kRxStateIdle:
                // look for first header byte
                if( c == v->data.header_aa )
                    serialRxState = kRxStateHeader;
                else
                    serialTimeoutStop(&timeout);
                break;

            case  kRxStateHeader:
                // look for second header byte
                if( c == v->data.header_55 )
                    serialRxState = kRxStateMessageType;
                else
                    {
                    // Bad message
                    serialTimeoutStop(&timeout);
                    serialRxState = kRxStateIdle;
                    }
                break;

            case  kRxStateMessageType:
                // We have a good header so next is message type
                v->data.message_type = c;
                serialRxState = kRxStateDatalen;
                break;

            case  kRxStateDatalen:
                // next is data length byte
                MyVexDataRx.data.datalen = c;
                serialDataReceived = 0;
                serialRxState = kRxStateData;
                break;

            case  kRxStateData:
                // receive the data packet
                MyVexDataRx.buffer[ VEXDATAOFFSET + serialDataReceived ] = c;
                if( ++serialDataReceived == v->data.datalen )
                    serialRxState = kRxStateId;

                // check for buffer overflow
                if( serialDataReceived >= (VEX_DATA_BUFFER_SIZE-VEXDATAOFFSET) )
                    {
                    // Error
                    serialTimeoutStop(&timeout);
                    serialErrs++;
                    serialRxState = kRxStateIdle;
                    }
                break;

            case  kRxStateId:
                // We have all the data so next is id
                v->data.id = c;
                serialRxState = kRxStateChecksum;
                break;

            case  kRxStateChecksum:
                // Received checksum byte

                // stop timeout
                serialTimeoutStop( &timeout );

                // calculate received checksum
                VexDataChecksum( v );

                // comapare checksums
                if( v->data.checksum == c )
                    {
                    // Good data
#ifdef  DEBUG
                    VexDataPrint( v );
#endif
                    serialRxDecode( v );
                    }
                else
                    serialErrs++;

                // done
                serialRxState = kRxStateIdle;
                break;

            default:
                serialRxState = kRxStateIdle;
                break;
            }
        }
}

/*-----------------------------------------------------------------------------*/
/*  serial receive task                                                        */
/*-----------------------------------------------------------------------------*/

task serialRxTask()
{
    // bump our priority
    setTaskPriority(serialRxTask, 20);

    // init the data, only needed for the header bytes really
    VexDataInit( &MyVexDataRx );

    // check for messages
    while( true )
        {
        // run the receive data state machine
        serialRx( &MyVexDataRx );

        // check for data often
        wait1Msec(2);
        }
}
